10/02


finire ft_unset  aspettare il parsing

finire ft_export  aspettare il parsing da controllare

fare un funzione che smista le builtins? non e necessario ma forse facilita le cose

dove mettere la fn che e in environment.c che copia environment e lo mette in t_ms? 
	t_envlst	*ft_env_cpy(t_envlst *myenv, char **matrix)



ft dollar funziona

finire parser.c






ALLOCAZIONI DA LIBERARE A FINE PROGRAMMA

la lista di environement variables che conservo in t_ms     la prendo a inizio programma e alla 
			fine la devo liberare

t_ms lo devo malloccare altrimenti va in segfaul,   ma dove?  nel main?
			quindi se malloc devo liberare

tutte i valori dentro t_ms che ho malloccato : myenv, cwd, 

tutte le liste che ho creato con malloc,  la lista di input, la lista di comandi, la lista di argomenti
			la lista di comandi la devo liberare a fine programma
			la lista di argomenti la devo liberare a fine programma
			la lista di input la devo liberare a fine programma

			
un ciclo che:
legge la linea
controlla se e valida
la mette nella lista e la espande
cerca gli operatori e fa il parsing
la mette in una struttura-array
la manda in esecuzione
salva il exit status
libera la lista con l'input
ricomincia

-----------------------------------------------------------------
read input
parse into command blocks

save stdin and stdout backup in m_ts

for each command block:
    - create pipes if needed
    - fork()
    - inside child:
        - if there is a pipe: dup2(pipe_fd, STDOUT) or STDIN
		- handle redirections (dup2)
        - execve()
    - inside parent:
        - close pipe fds
        - wait

after all:
    restore stdin and stdout from saved copy
    wait for all children
-----------------------------------------------------------------


double free, a lot of problems, how to risolve:
Set the pointer to NULL after free() to prevent accidental reuse.
Be careful with multiple pointers to the same memory: If two pointers reference the same allocated block, freeing one affects the other


LEGGI LEGGI LEGGI!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

cc=123456$USER
espande prima di salvarlo nelle envs

QUINDI GESTIRE QUESTA ESPANSIONE RICORSIVA PRIMA DI EXPOTARLO IN ENVS   gia fatto!
e dopo non mi serve piu la recursiva in ft_dollar_expansion lo posso levare o se mi fa fatica 
lo lascio
da fare

da finire export con calma quando avro i comandi in un array, il resto dovrebbe funzionare








commands:
cat < input.txt | grep "error" | sort | uniq > output.txt
cat < infile.txt | grep error | wc -l
echo "start" >> log.txt | grep "start" < input.txt
cat << EOF | grep world < input.txt >> output.txt
export "cia'o"=mondo -> deve dare errore
export 'cia"o'=mondo
export ciao+=mondo -> appende la stringa alla variabile gia esistente
export cia+o=mondo -> errore
echo ciao | > p -> deve dare errore (gia fatto)
echo ciao | > -> deve dare errore (gia fatto)
$ echo ciao | exit oppure ls | exit non fa niente (o meglio esesgue ls, lo scrive nella 
pipe poi esce dalla minishell cosi noi non vediamo il contenuto della pipe)
$ exit | ls esegue ls e non esce della minishell (segue ls ed esce dal suo child?)


cat < input | grep error < Makefile :se non esiste il file da errore,
	in ogni caso il grep lo fa su Makefiel, sia che input esista o non
First handle redirections, then if not redirections have made, handle pipes
oppure piu facile: 
Always set pipes first, redirections second â€” because redirections have the final word
Why?

    Redirections are more specific: if the user said cat < input.txt, they want to read from the file, not from the previous command's pipe.

    Pipes are the default connection only if no redirection replaces stdin or stdout.
If there is a redirection (<, >, >>, etc.), it overrides the pipe.

"|" ">" ">>" "<" "<<" devono essere trattati come args perche sono tra 
virgolette git logs ---> FATTO!!

echo "ciao mondo | |" -> non deve dare errore perche tra virgolette 

sytax errors in pipes:
>|	<|	>>|	<<|	|>	|<	|>>	|<<	||	| |


prima di consegnare:
levare tutti gli emoji e messaggi di errore utili per debug





23/04/25

le redirections si possono fare anche senza comandi:
> miofile
crea il file

< file
se deve leggere dal file e il file non esiste da errore: No such file or directory


TODO

int		handle_heredoc(char *delimiter); fare questa funzione

nel caso l'input sia ""  o '' gestire: errore di bash \n e Command '' not found
cacorrea@c1r4p8:~$ ""

Command '' not found, but can be installed with:
cacorrea@c1r4p8:~$ echo ciao | ""

Command '' not found, but can be installed with:


se un solo cmd e builtin  ----->  eseguo nel parent no faccio fork
se piu di un cmd ----->  eseguo nel sempre nel child

all'inizio con dup, salvare una copia di fd 0 e di fd 1 (che prenderanno il valore
di 3 e 4 che sono i primi fd liberi) per non perdere stdin e stdout
perche nel caso di heredoc mi serve stdin e in tutti i casi alla fine li
devo ripristinare prima di chiudere la shell
If you are inside a child process, maybe you don't need to restore (because the child will exit after execve)

fn aussiliare per controllare errore e fare dup2, le passi i due 
fd e fa il dup2, se fd del file aperto e -1 vuole dire che c'e stato un errore
con open

int help_dup(int file_fs, int input_output);
{
	if (file_fs == -1)
	{
		perror("open");
		return (-1); o dirgli di uscire
	}
	dup2(file_fs, input_output);
	close (file_fs);
}

gestire heredoc per conto suo, anche l'apertura del file, quando finisce 
chiudere il file con ulink.  serve get next line
dopo che ha finito di leggere, serve fare un'ulteriore chiamata a gnl per
liberare la statica???
















